
<html>
<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-153791322-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-153791322-1');
  </script>
    <!-- endof Global site tag (gtag.js) - Google Analytics -->



<style>
.accordion {
  background-color: #000;
  color: #fff;
  cursor: pointer;
  padding: 18px;
  width: 100%;
  border: 1px solid white;
  /* border-top: 0.1px solid black; */
  text-align: left;
  outline: none;
  font-size: 15px;
  transition: 0.4s;
}

.active, .accordion:hover {
  background-color: #000; 
}

/* panel css and js at bottom */

li.sick {
  color: rgb(38, 150, 255);
}

li.audited {
  color: rgb(52,168,83);
}

</style>


  <link rel="stylesheet" href="/static/style.css">
  <meta charset="utf-8">
  <title>Befriending the MachineÂ· Tanishq Kumar</title>
</head>
<body>
<div id="menu">
<span class="title">Tanishq Kumar</span>
<ul>
  <li><a href="/index.html">Home</a></li>
  <li><a href="/about.html">About</a></li>
  <!-- <li><a href="/culture">Culture</a></li> -->
  <li><a href="/books.html">Bookshelf</a></li>
  <li><a href="/essays.html">Essays</a></li>
    <!-- <li><a href="/notes.html">Notes</a></li> -->
    <!-- <li><a href="/articles.html">Articles</a></li> -->
      <li><a href="/courses.html">Coursework</a>
        <!-- <li><a href="/papers.html">Papers</a> -->
</ul>
</div>
<div id="left"></div>
<div id="content">

<h3>Befriending the Machine</h3>

<p>
Freshman fall, thinking that Harvard's introductory CS course (CS50) would be too easy, I took
 Harvard's systems programming course, thinking it was the natural next step. It kicked my ass, 
 and I learned only afterwarsd that despite it's low catalog number (61), many computer science majors 
 find it more difficult than more advanced -- even graduate -- classes. In particular, 
 I spent over 20 hours a week writing debugging C++. We covered the fundamentals of assembly, memory management, 
 kernels, networking and concurrency, shells, and caching. My foggy memories include 
 mad-rushes to draw diagrams of cache heirarchies in an attempt to debug a p-set in which we were writing a cache, 
 and deciding between a binary tree vs linked-list to implement my virtual shell that parses bash-like commands. 
 And, of course, the famed <a href="http://www.csc.villanova.edu/~mdamian/Past/csc2400fa16/labs/bomblab.pdf">
  binary bomb
 </a>. 
</p>

<p>
  The class turned out to be more formative than I think I realized at the time. I always wondered why future software 
  engineers would bother to learn systems programming (ie. how computers actually work on a low level) if they'd spend 
  their lives writing react code or some other business logic for a company that is much less involved than the kind of 
  programming that is done by systems experts. Of course, <i>some engineers</i> at Google write compilers 
  and browsers and operating systems and high-performance distributed systems. But the vast, vast majority don't. 
  So why practise or spend hundreds of hours learning such a thing in the first place? 
</p>

<p>
  The short answer is that systems programming, and classes that teach it, are mostly useful because not becaus e
  they are teaching you about memory or assembly. They are mainly teaching you to debug subconciously before 
  and while you write code, and to have unreasonable amounts of patience as you're doing so. 
</p>

<p>I like to think of it as "befriending the machine." An analogy I heard once that stuck with me is as follows. 
[analogy]
</p>

[TODO]

</div>

