
<html>
<>
    <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-153791322-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-153791322-1');
  </script>
    <!-- endof Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-153791322-1"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>
        <script>
            MathJax.Hub.Config({tex2jax: {inlineMath: [['$', '$']], displayMath: [['\(', '\)']]}});
        </script>

<style>
.accordion {
  background-color: #000;
  color: #fff;
  cursor: pointer;
  padding: 18px;
  width: 100%;
  border: 1px solid white;
  /* border-top: 0.1px solid black; */
  text-align: left;
  outline: none;
  font-size: 15px;
  transition: 0.4s;
}

.active, .accordion:hover {
  background-color: #000; 
}

/* panel css and js at bottom */

li.sick {
  color: rgb(38, 150, 255);
}

li.audited {
  color: rgb(52,168,83);
}

</style>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <link rel="stylesheet" href="/static/style.css">
  <meta charset="utf-8">
  <title>Notes on a physicist's perspective on deep learning theoryÂ· Tanishq Kumar</title>
</head>
<body>
<div id="menu">
<span class="title">Tanishq Kumar</span>
<ul>
  <li><a href="/index.html">Home</a></li>
  <li><a href="/about.html">About</a></li>
  <!-- <li><a href="/books.html">Bookshelf</a></li> -->
  <li><a href="/essays.html">Writing</a></li>
      <li><a href="/courses.html">Courses</a>
      <!-- <li><a href="/papers.html">Research</a> -->
</ul>
</div>
<div id="left"></div>
<div id="content">

<!-- <h3>Notes on a physicist's perspective on deep learning theory</h3> -->

        <ul>
<li><a href="https://arxiv.org/pdf/2106.10165.pdf">Deep learning theory, a physicist's perspective</a>
<ul>
<li><strong>Chapter 0 -- philosophy and motivation</strong>
<ul>
<li><a href="https://arxiv.org/pdf/2104.00008.pdf">Companion essay: why AI is harder than physics</a>
<ul>
<li>Prior motivation for using physical tools in ML: it's fundamentally about studying the emergent properties of strongly interacting systems whose microscopic details we understand. This is precisely the job of statistical mechanics!</li>
<li>Also, it should be noted that physics is not just a tool for studying <strong>natural</strong> phenomena. The theory of thermodynamics was invented <strong>after</strong> steam engines, so understand how to make more principled and bigger improvements to their design. </li>
<li>A first point is that AI is hard because there's no free lunch. The number of possible labelings for a set of images grows very fast. There is often structure in the world we can exploit to compute these labels efficiently, but the fact that deep learning models can perform well when this structure is not human-interpretable makes them difficult to reason about. </li>
<li>Conversely, he argues that there <strong>is</strong> a free lunch in physics. It is an empirical and surprising fact that there is so much structure in the world that the laws of physics have a low algorithmic complexity.
<ul>
<li>We can make this more precise. A QFT is characterized by its elementary particles and their interactions. The sum of all possible interactions is exponential in (p), the number of particles. More generally, if we have a system with (N) dof (eg. spins in a solid), generically we can have (\sum<em>i \binom{N}{i} \sim 2^N) interactions between the two. </li>
<li>If we had to have a parameter for each dof, this would mean we'd need exponentially many parameters for a system with (N) dof. This would mean that theories don't tell us much: they are just lookup tables for all possible interactions, where an experiment was done to determine each parameter that characterizes each different interaction. The "unreasonably low algorithmic complexity" point refers to the fact that this is <strong>not</strong> the case. 
<ul>
<li>This should remind us of how, generically, images can be exponentially many combinations of labels, so that generically learning labels in the absence of structure is hard. </li>
<li>The key point is that actual laws and theories of physics are <strong>sparse</strong>. We can describe exponentially many interactions with a small number of parameters. If instead of trying to introduce a parameter for all possible ((n \in [N]))-wise interactions, we limited to just interacting at most (k)-wise interactions for (k \ll N), then we'd only need (O(N^k)) parameters to characterize all possible interactions. This is saying that we might enforce that any interaction can be between no more than (k \ll N) particles.</li>
<li>However, the universe has even stronger sparsity than this! In fact, we have <strong>spatial locality</strong>, no just (k)-locality. This means the maximum amount of interactions of particles is capped at how many other particles can physically be near them. Due to the properties of 3D space, this isn't all that many! Space is only a meaningful notion because of this locality -- if a particle on earth and on Saturn interacted just as strongly and easily and quickly as two neighboring particles on Earth, "space" would have no meaning at all. 
<ul>
<li>Note that with this constraint, a particle in (d) dimensions can only have (2d) neighbors, so that now the interactions we need in our look-up table are linear in the number of particles, not even polynomial!</li>
</ul></li>
<li>Our final empirical sparsity condition is <strong>translation invariance</strong>. We don't even need to study every particle separately, since we observe that the laws governing one particle are the same as the laws governing all particles. This means that size of our look-up table reduces to a constant size, (O(1))!</li>
</ul></li>
<li>This is what is meant by physics having a surprisingly low algorithmic complexity. Our simple mathematical descriptions have a complexity as objects that is <strong>stunningly smaller</strong> than the objects and dynamics they describe. The universe has been kind to us!</li>
<li><strong>The key point of the essay is that physical systems are interacting multi-body systems whose dynamics we want to understand, and this is made easier by the plethora of sparsity constraints the universe has given us to understand these systems. Neural networks, as mathematical objects, are under no such sparsity constraints, so as coupled dynamical systems, they are strictly more difficult to reason about! Physics is easy compared to AI!</strong></li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>Chapter 1 -- tools for Gaussian integrals and perturbation arguments</strong>
<ul>
<li>This is important because it introduce some objects common in Blake's arguments: Wick's theorem, perturbation arguments, source terms, observables, correlation functions, moment generating functionals, the action, and more. </li>
<li>^^Keywords, key ideas and dictionary^^
<ul>
<li><strong>Gaussian integrals</strong>
<ul>
<li>These are key primitives in physics, since everything is Gaussian by CLT of lots of interacting particles. An example is (I = \int<em>{-\infty}^\infty \exp(-z^2/2)), which can be computed by changing to co-ordinates. To see this, observe that (I^2 = \int</em>{-\infty}^\infty \int<em>{-\infty}^\infty dxdy \exp(-(x^2 + y^2)/2) = \int</em>0^\infty rdr \int<em>0^{2\pi} \exp(-r^2/2) = 2\pi), so that (I = \sqrt{2\pi}). The extra factor of (r) comes from the chain rule in the change of variables to polar co-ordinates. </li>
<li>Now for a general Gaussian rv with mean (s) and variance (K) we write (I<em>{K,m}) as the corresponding Gaussian integral (I</em>{K,m}). Note this is the normalizing factor in the normal distribution with that mean and variance. We can indeed check that for such a rv  (z), we have (E[z] = \int<em>{-\infty}^\infty dzp(z)z = \frac{1}{\sqrt{2\pi K}}\int</em>{-\infty}^\infty dz \exp(-(z-s)^2/2K)z = s) by doing the integral at the end out explicitly using a change of variables (z \to z - s) and using that odd integrals from ((-\infty, \infty)) vanish. Thus we've sanity checked that the normal PDF for a set mean and variance does indeed give that mean and variance. </li>
<li>Now consider centered Gaussians. Let (O(z)) represent some observable of an underlying physical random variable; we will often be concerned with reasoning about expectations and higher order moments of observables. Of course, moments (O(z) = z^M) are special values of observables. From polynomial approximation, we know that characterizing the expectations of these observables characterizes (E[f(z)]) for any function (z), and thus the distribution of (z) in its entirety. Thus a rvs distribution (and general behavior) is characterized by its moments, motivating their study. </li>
<li>We note odd moments of the standard normal vanish, so we're more concerned with efficient ways to compute even moments for (M = 2m, m \in \mathbb{N}). There exist a neat trick seeing that (I<em>{K, m} \equiv \int</em>{-\infty}^\infty dz \exp(-z^2/2K)z^{2m} = \left(K^2\frac{d}{dK}\right)^m = \int<em>{-\infty}^\infty dz \exp(-z^2/2K) = \left(2K^2 \frac{d}{dK}\right)^mI</em>K = K^m(2m-1)!!) where we note we've abused notation so that now (I</em>{K,m}) is the Gaussian integral we're computing to find (E[z^{2m}]). 
<ul>
<li>Note how higher order moment calculations have thus been reduced to evaluating double factorials. This is known as (the single variable) <strong>Wick's theorem</strong>, and is absolutely fundamental in probability and SFT for computing higher order moments. </li>
</ul></li>
<li>Now we'll rederive this another way that extends more easily to the multivariate case, by adding a dummy term to our original Gaussian integral called a <strong>source term</strong>, (J). This has a physical interpretation in physics, but here it's just a dummy quantity including which will make the integral easier for reasons we'll see. 
<ul>
<li>Define (Z<em>{K,T} \equiv \int</em>{-\infty}^\infty dz \exp(-z^2/2K + Jz)) and see that this partition function is just (E[e^{Jz}]). Since it's an MGF for the rv of interest, (z), we can read all the higher order moments for (z) off the Taylor expansion of this integral around (J=0), which is precisely what Wic's theorem aims to do. </li>
<li>Doing this out, we get that (\begin{aligned}
\mathbb{E}\left[z^{2 m}\right] &amp; =\frac{I<em>{K, m}}{\sqrt{2 \pi K}}=\left.\left[\left(\frac{d}{d J}\right)^{2 m} e^{\frac{K J^2}{2}}\right]\right|</em>{J=0}=\left.\left{\left(\frac{d}{d J}\right)^{2 m}\left[\sum<em>{k=0}^{\infty} \frac{1}{k !}\left(\frac{K}{2}\right)^k J^{2 k}\right]\right}\right|</em>{\substack{J=0 \
(1 .}} \
&amp; =\left(\frac{d}{d J}\right)^{2 m}\left[\frac{1}{m !}\left(\frac{K}{2}\right)^m J^{2 m}\right]=K^m \frac{(2 m) !}{2^m m !}=K^m(2 m-1) ! !
\end{aligned}) which is precisely Wick's theorem in the single-variable case.  Note that the term (\exp(KJ^2/2) \equiv Z<em>{K,J}/I</em>K) is where the partition function enters, and we take the (2m)-th derivative because that's the moment we want (recall how we read moments off of MGFs from Stat 210). </li>
</ul></li>
</ul></li>
<li><strong>Partition function as MGF</strong>
<ul>
<li>Note that a crucial observation is that in thermodynamic systems, that probability of a particle being in a state (s) is given by the Gibbs measure (\exp(-\beta H(s))). The partition function, as we know, just averages over this measure (Z = \int ds \exp(-\beta H(s))). The crucial observation as we saw above is that the Gibbs measure precisely implies (Z \equiv E<em>s[e^{-\beta H}]) that the partition function is the moment generating function over the random variable (H(s)). Thus knowing the partition function means knowing the distribution of (H), which is knowing the distribution over states, which is precisely the goal of statistical mechanics. This is what is meant by saying "knowing the partition function is equivalent to solving out the properties of the system." 
<ul>
<li>This is also why derivatives of the partition functions encode important quantities. For instance, we expect the first moment to be the mean of the random variable, ie. the average energy of the system over movement through random states. This is exactly the relation between the partition function and free energy. Then </li>
</ul></li>
</ul></li>
<li><strong>(M)-point correlators</strong>
<ul>
<li>Instead of calling (E[z<em>1z</em>2 \cdots z</em>m]) a moment of order (m), physicists (not unreasonably) call it an (m)-point correlator, since it's a function that measures the correlation between, well, (m) points. Of course when we examine the dynamics of a strongly correlated system, these will appear in the "Taylor expansion" of all possible interactions, which is why being able to compute them easily is important, motivating the theory above. </li>
</ul></li>
<li><strong>Proof of multivariate Wick's theorem</strong>
<ul>
<li>We established the single-variable theorem above, and here we state the general version. </li>
<li>Recall first the PDF of the MVN. The determinant factor comes from the fact that we diagonalize when computing the multidimensional integral with (K) in it, so we should expect its spectrum to appear in the normalizing factor. Thus we recall (p(z) = \frac{1}{\sqrt{|2\pi K|}} \exp\left[-\frac{1}{2}\sum<em>{\mu \nu}^N (z-s)</em>\mu K^{\mu \nu} (z-s)<em>\nu\right]) where superscript on the covariance matrix denotes inverse, and so the mean vector and covariance matrix for this MVN are (s, K). </li>
<li>Now we seek the moments (E[\prod<em>{i=1}^M z</em>{\mu<em>i}]). We reason by analogy to the single variable case. Moments with odd numbers of terms vanish and so let (M = 2m). To find this, we need to compute the generating function (Z</em>{K,J} \equiv \int d^Nz \exp\left(-\frac{1}{2} \sum<em>{\mu \nu} z</em>\mu K^{\mu \nu}z<em>\nu + \sum</em>\mu J^\mu z</em>\mu \right)). 
<ul>
<li>Side note: this kind of reminds me of the partition function of the Hamiltonian of an Ising model, but I'm not sure exactly what the relation is. </li>
<li>We can find this in closed form by integrating by hand and eventually getting that it's equal to (\sqrt{|2\pi K|} \exp\left(\frac{1}{2}\sum<em>{\mu \nu} J^\mu K</em>{\mu \nu}J^nu\right)). </li>
</ul></li>
<li>As before, we can get the moments by taking many derivatives of the partition function above. We have that (\begin{aligned}
\mathbb{E}\left[z<em>{\mu</em>1} \cdots z<em>{\mu</em>{2 m}}\right] &amp; =\left.\frac{1}{I<em>K}\left[\frac{d}{d J^{\mu</em>1}} \cdots \frac{d}{d J^{\mu<em>{2 m}}} Z</em>{K, J}\right]\right|<em>{J=0} \
&amp; =\frac{1}{2^m m !} \frac{d}{d J^{\mu</em>1}} \frac{d}{d J^{\mu<em>2}} \cdots \frac{d}{d J^{\mu</em>{2 m}}}\left(\sum<em>{\mu, \nu=1}^N J^\mu K</em>{\mu \nu} J^\nu\right)^m .
\end{aligned})</li>
<li>This is the key bridge between moments of a normal and combinatorics: the combinatorics arise by examining how many terms in the binomial-type expansion in the brackets "survive" after all the derivatives, and what form they take. Thus we should expect a combinatoric formula in terms of the covariance function's indices (that will be some mixture of (\mu<em>1, \cdots, \mu</em>{2m}), since only terms containing all of those terms will survive under the successive derivatives), so for instance (\left(J^{\mu<em>1} \right)^m K</em>{\mu<em>1 \mu</em>1}\left(J^{\mu<em>1} \right)^m) would not survive the derivatives, so won't show up in the moment. </li>
<li>The final form is (E[z<em>{\mu</em>1}\cdots z<em>{\mu</em>{2m}}] = \sum<em>{p \in \text{partitions of } [2m] \text{ into } m \text{ pairs }}\prod</em>{i, j: \text{elements in the pair,} p} K<em>{\mu</em>i, \mu</em>j}) where each term in the sum is the product of (m) covariance entries, each called a <strong>Wick contraction</strong>. 
<ul>
<li>If you do the counting, there will be ((2m-1)!!) terms in the sum, as in the single variable case. </li>
<li>We used the normal PDF to derive these things, sure, but the point is this is special to the normal because we're characterizing all higher moments (and thus the distribution) purely in terms of the covariance. Recall that only a normal is characterized by its first two moments. </li>
</ul></li>
</ul></li>
<li><strong>Cumulants, or, connected correlators</strong>
<ul>
<li>The goal on the horizon is being able to extend the parsimony of distributional description that Normal rvs have to nearly-Gaussian settings. First note that physicists call cumulants "connected correlators" as opposed to the (M)-point correlators we saw above (which will sometimes be referred to as "full correlators").
<ul>
<li>To refresh ourselves, remember that a CGF is just (K(t) = \log M(t)). For instance, the famous (\log Z) is a cumulant-generating function, since the partition function is itself a moment generating function. These were invented because they have many nice properties that moments don't. Recall this section from the Stat 210 book: 
<ul>
<li><img src="https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2Ftanishq%2F34_MIBnhdj.png?alt=media&token=6d544ef3-a0db-4a36-944e-eb2141af7566" alt="" /></li>
</ul></li>
<li>The first cumulant is the mean, and the second is the covariance. A key nice property that many nearly-Gaussian rvs have (that's what we mean by "nearly" Gaussian) is the <strong>parity symmetry</strong>, or invariance of distribution under sign flip of the rv, that a normal rv enjoys (ie. its PDF is symmetric about the vertical axis). For any rv that has this property, all odd moments and cumulants vanish, as expected. </li>
<li>Thus, after the covariance -- the second cumulant -- the natural object of study is the fourth cumulant, the kurtosis (up to scaling, really we need to divide the fourth moment by the variance to get the Kurtosis). It turns out this is a fantastic measure of Gaussianity, since Normal rvs have unusually thin tails due to exponential decay in the PDF. The Gaussian has zero Kurtosis, and its deviation above (fatter tails) or below (thinner tails) tells us about how non-Gaussian a rv is. </li>
<li>The inductive definition of cumulants mean that we can express higher order cumulants as sums of the moments. Recall we can compute all moments of a Gaussian easily by Wick, so that we can compute all cumulants easily, too. 
<ul>
<li>It turns out for the Gaussian, the sixth moment vanishes, so that all cumulants after the covariance are actually zero, so the values of the higher cumulants are a natural measure of non-Gaussianity. </li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>Near-gaussianity and the action</strong>
<ul>
<li>Now that we have some measure of non-Gaussianity, what can we say, given the cumulants, about the functional form of a near-Gaussian distribution? We will do this using a quantity (S(z)) called the action. </li>
<li>This is just the negative log probability, ie. a function of our rv (z) such that (p(z) \propto \exp(-S)). For instance, for (z) being the states of a thermodynamic system -- say a spin glass -- the action is the Hamiltonian since it defines the probably of a state through precisely the Gibbs measure. 
<ul>
<li>Because we defined it as above, we get that (Z \equiv \int d^Nz \exp(-S(z))) so that (p(z) \equiv \exp(-S(z))/Z).</li>
<li>Of course, this means given a probability distribution (p(z)) we can define an action (S(z) \equiv - \log p(z)) up to proportionality due to the additive effect of the partition function in log space. </li>
<li>In particular, for a Gaussian, we of course have the action is the thing in the exponent of the PDF by construction, so that (S(z) = \frac{1}{2}\sum<em>{\mu, \nu} K^{\mu, \nu}z</em>\mu z</em>\nu). This is called a quadratic action. To study near-Gaussians, we'll add a coupling term that will make this deviate from Gaussianity. 
<ul>
<li>In particular, we let (S(z)=\frac{1}{2} \sum<em>{\mu, \nu=1}^N K^{\mu \nu} z</em>\mu z<em>\nu+\frac{\epsilon}{4 !} \sum</em>{\mu, \nu, \rho, \lambda=1}^N V^{\mu \nu \rho \lambda} z<em>\mu z</em>\nu z<em>\rho z</em>\lambda). </li>
<li>The term (\epsilon) controls the degree of coupling, and in neural net in fact (\epsilon \propto \frac{1}{N}) which gives convergence to a Gaussian distribution as width blows up. </li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>Perturbation theory</strong>
<ul>
<li>To quantify how much the distribution with action (S^{\text{quartic}}(z)) deviates from Gaussian, we should check its fourth cumulant (roughly its Kurtosis) to see how large that is. To calculate this, we seek the MGF as usual, now given by (\begin{aligned}
Z &amp; =\int\left[\prod<em>\mu d z</em>\mu\right] e^{-S(z)} \
&amp; =\int\left[\prod<em>\mu d z</em>\mu\right] \exp \left(-\frac{1}{2} \sum<em>{\mu, \nu} K^{\mu \nu} z</em>\mu z<em>\nu-\frac{\epsilon}{24} \sum</em>{\rho<em>1, \ldots, \rho</em>4} V^{\rho<em>1 \rho</em>2 \rho<em>3 \rho</em>4} z<em>{\rho</em>1} z<em>{\rho</em>2} z<em>{\rho</em>3} z<em>{\rho</em>4}\right) \
&amp; =\sqrt{|2 \pi K|}\left\langle\exp \left(-\frac{\epsilon}{24} \sum<em>{\rho</em>1, \ldots, \rho<em>4} V^{\rho</em>1 \rho<em>2 \rho</em>3 \rho<em>4} z</em>{\rho<em>1} z</em>{\rho<em>2} z</em>{\rho<em>3} z</em>{\rho<em>4}\right)\right\rangle</em>K .
\end{aligned})</li>
<li>Noting that (\epsilon \ll 1) is small, we can Taylor expand the exponential in the Gaussian expectation and drop all but the first term. This approximation is accurate because (\epsilon) is small, and it is precisely this Taylor expansion that is referred to as a <strong>perturbation argument</strong> since (\epsilon) is the magnitude of the perturbation away from Gaussianity. Then we can use Wick's theorem to bash the fourth cumulant as we'll see we  get something in terms of a Gaussian 4-th moment. 
<ul>
<li>(\begin{aligned}
Z &amp; =\sqrt{|2 \pi K|}\left\langle 1-\frac{\epsilon}{24} \sum<em>{\rho</em>1, \ldots, \rho<em>4} V^{\rho</em>1 \rho<em>2 \rho</em>3 \rho<em>4} z</em>{\rho<em>1} z</em>{\rho<em>2} z</em>{\rho<em>3} z</em>{\rho<em>4}+O\left(\epsilon^2\right)\right\rangle</em>K \
&amp; =\sqrt{|2 \pi K|}\left[1-\frac{\epsilon}{24} \sum<em>{\rho</em>1, \ldots, \rho<em>4} V^{\rho</em>1 \rho<em>2 \rho</em>3 \rho<em>4}\left\langle z</em>{\rho<em>1} z</em>{\rho<em>2} z</em>{\rho<em>3} z</em>{\rho<em>4}\right\rangle</em>K+O\left(\epsilon^2\right)\right]
\end{aligned})</li>
<li>This higher order coupling trick should remind you of how we'd induce arbitrary dependencies between nodes in a graphical model by putting a multiplicative (\psi(x<em>i, x</em>j, x<em>k)) term in the factorization of their PDF. </li>
</ul></li>
<li>We can use the partition function to them compute the Kurtosis, which will be in terms of the second and fourth moments, which we can compute using Wick's theorem and the same partition function. After a ton of bashing, we'll get the final Kurtosis (fourth cumulant, really) to be (-\epsilon \sum<em>{\rho</em>1, \ldots, \rho<em>4} V^{\rho</em>1 \rho<em>2 \rho</em>3 \rho<em>4} K</em>{\mu<em>1 \rho</em>1} K<em>{\mu</em>2 \rho<em>2} K</em>{\mu<em>3 \rho</em>3} K<em>{\mu</em>4 \rho</em>4}+O\left(\epsilon^2\right)). 
<ul>
<li>Importantly, note that the moment structure at <strong>all moments</strong> is slightly different due to this perturbation from Gaussianity, including the covariance, which is not exactly (K) for the near-Gaussian random variable. </li>
<li>One way to see this is that for a truly Gaussian rv with arbitrary (K), we can find a basis in which the random vector has independent components (ie. (K) is diagonalizable). However, inducing higher order correlations like we just did means that no linear transformation will "cleanse those," and the variable is fundamentally non-Gaussian now. Thus we have a breakdown of independence alongside this non-Gaussianity. </li>
<li>Also importantly, we can't compute closed forms for the partition function or correlators of a non-Gaussian, which is why we had to resort to perturbation theory (a Taylor approximation) here. </li>
</ul></li>
<li>In the way outlined here, we can induce couplings of arbitrary degree that quantify how non-Gaussian our random variable is. These couplings control the <strong>interactions</strong> between terms. </li>
<li>These ideas are relevant downstream in neural networks because wide (but not infinitely wide) neural nets have their activations and preactivations (whose dynamics the book argues are the key quantities in neural networks) given by nearly-Gaussian random vectors. The key contribution of the book is that it does the same perturbation theory for these networks, accounting for first-order deviations from Gaussianity in these random vectors (ie. they have Kurtosis), which accounts for most of the deviation from the infinite width limit. It turns out that the (2m)-th cumulant in these networks is order (O(\epsilon^{m-1})). </li>
<li>In practice, when using perturbation theory, we stick with a quartic action as anything beyond that becomes too unwieldy to reason about and often those corrections are vanishingly small and sometimes can't even be resolved!</li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>Chapter 2 -- Neural network basics</strong>
<ul>
<li>A key idea here is to not think about weights and biases as the primitive rvs but instead to think of the induced distribution over the preactivations as the key primitive. We fix a dataset and the randomness over parameters leads to randomness over the preactivations (z^{(\ell)}<em>i) for neuron (i) in layer (\ell). These are what this book mostly reasons about, since tracking preactivations characterizes network dynamics (and predictions) completely. </li>
<li>It's interesting to note that many parameterized function classes can be used for function approximation. For instance, we can approximate functions as sums of many Gaussians, where the parameters are means and variances. But we don't do this because NNs were a function class initially motivated by the brain. </li>
<li>We can think of biases as just the threshold for firing in a binary firing rate setting. </li>
<li>A cool view on inductive biases is that they induce constraints on, or relationships, between the weights. For instance, weight tying is when you constrain weights in different places to be the same, and we can see the convolutional architecture as being defined by a tied set of weights across space (translational symmetry of weights). This bias reduces the effective number of weights we need to learn by a lot. </li>
<li>He makes the point that scale invariance is a key property in an activation function, and proves that only linear and ReLU activations satisfy this. Many people try to make ReLU smooth by finding close smooth approximations, but none of these have exact scale-invariance, which is useful both to reason about networks and to be able to easily tune parameters to avoid blow-up. </li>
<li>A cool view on why we don't initialize all params at zero is that then they are symmetric, so the network only behaves as it has one effective neuron, since all the weights would move together as one under GD. Note that the resulting goal of moving to initializing weights from a probability distribution is to fin a distribution so that <strong>the resulting ensemble of networks are usually well behaved with respect to the function approximation task at hand</strong>. </li>
<li>Part of the goal of deep learning theory is to find exact prescriptions for hyperparameter tuning (which we know is absolutely crucial to network performance) that are provably optimal across a wide range of settings. </li>
<li>The ultimate goal of the book is to compute (p(z^{(L)}|D)) the distribution of output preactivations given a dataset (where the distribution is over randomness in weights). </li>
<li>A note: a <strong>self-averaging</strong> random variable (z) is one where (E[f(z)] = f(E[z])) for all (f). A random variable obeys this property if and only if it is Dirac delta distributed </li>
</ul></li>
<li><strong>Chapter 3 -- MLPs at initialization</strong>
<ul>
<li>This is a key chapter for developing conceptual tooling and intuition for how non-Gaussianity increases with depth of the network. It studies the deep linear network, which the author interestingly refers to as the "simple harmonic oscillator" of DL. </li>
<li>A cool point is that deep linear networks represent a smaller set of functions than general linear transformation. This can be seen by imagining a one-neuron-hidden layer that necessitates some compression. It doesn't seem like enforcing a bottleneck would maintain our ability to represent any matrix. </li>
<li>We will ultimately compute (p(z^{(L)}|D)) for a deep MLP <strong>at initialization</strong>. We will do this by computing all the moments of the final layer preactivations (by computing all the moments of every layer's preactivations and inducting on layer). It turns out once we have the right setup and primitives, "inducting" this initialized setup based on new data will not be too hard, so treating the case of trained MLPs evolving in response to data will be the "inductive step" to this chapter's "base case."</li>
<li>A key fact we'll use is (\mathbb{E}\left[W<em>{i</em>1 j<em>1}^{(\ell)} W</em>{i<em>2 j</em>2}^{(\ell)}\right]=\delta<em>{i</em>1 i<em>2} \delta</em>{j<em>1 j</em>2} \frac{C<em>W}{n</em>{\ell-1}}). 
<ul>
<li>This basically says the entries of a layer's weight matrix are independent, and have variance (\frac{C<em>W}{n</em>{\ell -1 }}). </li>
</ul></li>
<li>First we begin by fixing a data set (D) that we want to evaluate our network's output on (we <strong>are not training on this data set -- this is an important fact to remember</strong>). Since we seek to work towards understanding all the moments of (z^{(L)}), let's begin by understanding the moments in the first layer. Also note that (E[z</em>{i;a}^{(\ell)}] = 0)  where (i) is neuron and (a) is index in the dataset of the data point fed in to get this preactivation. This is true because the weights are centered. </li>
<li>Let's now move to computing the second moment, which will illustrate some important techniques. 
<ul>
<li>We can write (\begin{aligned}
\mathbb{E}\left[z<em>{i</em>1 ; \alpha<em>1}^{(1)} z</em>{i<em>2 ; \alpha</em>2}^{(1)}\right] &amp; =\sum<em>{j</em>1, j<em>2=1}^{n</em>0} \mathbb{E}\left[W<em>{i</em>1 j<em>1}^{(1)} x</em>{j<em>1 ; \alpha</em>1} W<em>{i</em>2 j<em>2}^{(1)} x</em>{j<em>2 ; \alpha</em>2}\right] \
&amp; =\sum<em>{j</em>1, j<em>2=1}^{n</em>0} \mathbb{E}\left[W<em>{i</em>1 j<em>1}^{(1)} W</em>{i<em>2 j</em>2}^{(1)}\right] x<em>{j</em>1 ; \alpha<em>1} x</em>{j<em>2 ; \alpha</em>2} \
&amp; =\sum<em>{j</em>1, j<em>2=1}^{n</em>0} \frac{C<em>W}{n</em>0} \delta<em>{i</em>1 i<em>2} \delta</em>{j<em>1 j</em>2} x<em>{j</em>1 ; \alpha<em>1} x</em>{j<em>2 ; \alpha</em>2}=\delta<em>{i</em>1 i<em>2} C</em>W \frac{1}{n<em>0} \sum</em>{j=1}^{n<em>0} x</em>{j ; \alpha<em>1} x</em>{j ; \alpha<em>2}
\end{aligned})</li>
<li>And then define (G<em>{\alpha</em>1 \alpha<em>2}^{(0)} \equiv \frac{1}{n</em>0} \sum<em>{i=1}^{n</em>0} x<em>{i ; \alpha</em>1} x<em>{i ; \alpha</em>2}) to see that (\mathbb{E}\left[z<em>{i</em>1 ; \alpha<em>1}^{(1)} z</em>{i<em>2 ; \alpha</em>2}^{(1)}\right]=\delta<em>{i</em>1 i<em>2} C</em>W G<em>{\alpha</em>1 \alpha<em>2}^{(0)}). 
<ul>
<li>In particular, the (G) term tells us about the correlation structure of the dataset. This is just the (G) for the inputs. The next layer's (G) is defined similarly, but based on the first layer, so that (G^0<em>{\alpha</em>1, \alpha<em>2} \equiv \frac{1}{n</em>1} \sum<em>j^{n</em>1} E[z<em>{j,\alpha</em>1}z<em>{j,{\alpha</em>2}}]). It turns out this is a fundamental quantity we can write all moments in terms of, so in some sense this is the right primitive to determine the distribution of preactivations. 
<ul>
<li>Intuitively, we should think of the (G) term as representing the average over neurons of "how correlated is the neuron's activity for input (\alpha<em>1) to its activity for input (\alpha</em>2)." </li>
<li>In short, we can think of (G^{\ell}<em>{\alpha</em>1, \alpha<em>2}) as representing the "mutual information" that (\alpha</em>1, \alpha</em>2) have on predicting each others firing rate for neurons in layer (\ell). </li>
</ul></li>
<li>The final recurrence turns out to be (G<em>{\alpha</em>1 \alpha<em>2}^{(\ell)}=\left(C</em>W\right)^{\ell} G<em>{\alpha</em>1 \alpha</em>2}^{(0)}). 
<ul>
<li>What does this mean? For one, if (C<em>W \neq 1) then we blow up or vanish, so that (C</em>W = 1) is a <strong>critical point</strong>. Modern DL operates in this regime since networks would otherwise be useless. </li>
</ul></li>
</ul></li>
<li>So now we have a form for the second moment of the desired distribution (p(z^{(L)}|D)). Let's find the fourth moment to see how this deviates from Gaussianity. It turns out to take the form (G<em>4^{(\ell)}=\left[\prod</em>{\ell^{\prime}=1}^{\ell-1}\left(1+\frac{2}{n<em>{\ell^{\prime}}}\right)\right]\left(G</em>2^{(\ell)}\right)^2). The task of the rest of the chapter is cleanly interpreting this. </li>
<li>Note first that for a Gaussian, the product evaluates to one as the fourth moment is just the second moment squared. Also note that this is exactly what happens as we take all widths to infinity. This is why wide networks behave as Gaussian processes (roughly, this means that the joint distribution of all layers is MVN for a large vector). 
<ul>
<li>Note that this is not obvious a priori because each neuron in a later layer is the sum of many Gaussian terms, <strong>some of which are raised to a power</strong>, and we know of course that Gaussian rvs are not closed under polynomial transformations.</li>
</ul></li>
<li>This tells us that each layer is an "opportunity to deviate from Gaussianity," so that it should not be surprising that later layers are non-Gaussian in their joint distribution. Crucially, it's important this is the case, because if I'm classifying cat images and my final layer gets preactivations that are perfectly Gaussian, that earlier networks <strong>didn't do their fucking job</strong> of finding useful <strong>non-random</strong> features that make classification easy. Thus the development of non-Gaussianity is a feature, not a bug, even if it makes theoretical analysis harder. It's ironic that the extent to which a network is useful is precisely that to which it resists theoretical analysis. Maybe this tell us the whole project of closed-form MLT for MLPs is epistemically misguided? </li>
<li>Let's investigate this more closely by setting all the widths equal to some (1 \ll n \ll \infty). 
<ul>
<li>Plugging into the above equation, we get exactly that (\begin{aligned}
G<em>4^{(\ell)}-\left(G</em>2^{(\ell)}\right)^2 &amp; =\left[\left(1+\frac{2}{n}\right)^{\ell-1}-1\right]\left(G<em>2^{(\ell)}\right)^2 \
&amp; =\frac{2(\ell-1)}{n}\left(G</em>2^{(\ell)}\right)^2+O\left(\frac{1}{n^2}\right)
\end{aligned})</li>
<li>This has a few key interpretations on the nature of finite-width corrections
<ul>
<li>First, that non-Gaussianity is a function of the emergent scale/aspect ratio (\ell/n)</li>
<li>Second, that it increases linearly with layer depth. In particular, if we remember the quartic coupling in the action that caused deviation from Gaussianity in section 1, we can interpret this as saying that this coupling increases with layer depth. (In fact, we say this "runs" with layer depth, in the language of renormalization group flow which will be introduced later; damn physicists and their jargon). </li>
<li>Third, this is equivalent to saying that the deviation of (z<em>j^{(\ell)}z</em>j^{(\ell)}) from its expectation on a fixed neuron (j) is correlated with the deviation of neuron (k) from <strong>its</strong> mean. Thus finite width differences control intralayer interactions between neurons, where these intralayer interactions get stronger with depth. 
<ul>
<li>The overall intuition to take away is that width plays a stabilizing role in reducing preactivation distribution's variance, and depth increases it. This is kind of like a bias-variance trade-off. </li>
<li>As depth increases, the typical magnitude of the preactivations deviates from its mean, so that if we take a thin, very deep network and try to use it in practice, it'll suffer convergence issues on many random initializations of weights. </li>
<li>This underscores the key theme of the book: <strong>the leading finite-width contributions at criticality grow linearly with depth, despite being suppressed by the inverse of the layer widths.</strong></li>
</ul></li>
</ul></li>
<li>Importantly, since (0 &lt; L/n \ll 1), we can use (\epsilon = n/L) as our perturbation parameter to do Taylor expansions around. Precisely the regime in which deep learning is effective is the regime where effective theories from physics that make use of perturbation approximations, are valid. </li>
</ul></li>
<li>Just as we computed the second and fourth moment for the final layer preactivations over random initialization weights, we can compute higher moments using Wick's theorem in the same way. Turns out higher moments have higher order dependencies on the aspect ratio (L/n), so they roughly vanish as we expect that to be much less than one. That wraps up the chapter!</li>
</ul></li>
</ul></li>
<li><strong>Chapter 6 -- Bayesian Learning</strong>
<ul>
<li>TODO</li>
</ul></li>
</ul></li>
</ul>

    </div>

